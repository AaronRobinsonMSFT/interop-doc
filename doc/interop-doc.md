# .NET Interop Document

**Context for this document is always relative to the [current release of the .NET platform.](https://dotnet.microsoft.com/download)**

### Contents

- [Introduction](#intro) &ndash; Introduction to how interoperability works in .NET.
    - [Terminology](#terms).
    - [Transitioning between Managed and Native](#transition).
- [Concepts](#concepts) &ndash; Fundamental ideas in .NET interoperability.
    - [Garbage Collection](#gc) &ndash; Pinning and `GCHandle`s.
    - [Referencing Memory](#referencingmemory).
    - [Blittable vs Unmanaged types](#blittablevsunmanaged).
- [C++/CLI](#cppcli) &ndash; Merging .NET and C++ into a single language.
    - [C++ language extensions](#cppcli_cpplangext).
    - [Activation of the .NET runtime](#cppcli_activation).

<!-- 
- [IL Stubs and Reverse IL Stubs](#ilstubs) &ndash; How stubs are generated and runtime optimizations.
    - [Diagnostics] &ndash; How to see the generated IL Stub.
- [COM and `IUnknown`](#comiunknown) &ndash; COM interoperability in .NET.
    - [WinRT](#winrt)
- [Migration from .NET Framework](#migration) &ndash; Options when migrating from .NET Framework.
- [Gotchas](#gotchas) &ndash; Common interop issues.
-->
- [Tooling](#tooling) &ndash; Tools that can help building interop scenarios.

## Introduction <a name="intro"></a>

The .NET interop system is an intrinsic part of the .NET platform and its impact can be observed down to the binary level &ndash; defined in [ECMA-335][spec_ecma335]. The representation of C language function exports with the common [x86 calling conventions][wiki_x86callconv] at the time of writing are literally able to be encoded at the lowest readable level. The lowest level in this case is termed "Intermediate Language" or "IL". The point of interop in .NET is to express in IL how software _not_ defined in IL and _not_ the .NET platform itself should work with logic and data owned and managed by a .NET runtime implementation.

An example is warranted. Imagine wanting to call the following C function from a .NET language (for example, C#).

```C
// Return the sum of the supplied array of integers.
int32_t sum_ints(int32_t length, int32_t* integers)
{
    int32_t acc = 0;
    for (int32_t i = 0; i < length; ++i)
        acc += integers[i];
    return acc;
}
```

In order to call this function it must first be declared in a manner that permits being called in C#. The .NET runtime will also need to know the name of the C library the function is defined in. The arguments to this function must also be considered. Since the first argument is a primitive type in both C and .NET (that is, a 4 byte integer) how it is passed to this function is relatively straight forward. The second argument is more complicated because it is an array. In order to pass a C# array naturally to this function, the .NET runtime must convert an `int[]` to a C `int32_t*`. This is the nature of .NET interoperability &ndash; working with a system that is not .NET.

### Terminology <a name="terms"></a>

Understanding the .NET interop domain is difficult without defining common jargon. Below is a list of terms used throughout this document. Terms are **bolded** in definitions when also defined in this section.

[**Blittable**][doc_blittable] &ndash; Data that has the same representation within and outside the .NET platform. Blittable data doesn't need to be **marshalled**. This term is a concept and not explicitly defined by the ECMA-335 specification or any .NET language.

**IL Stub** &ndash; A function generated by the .NET runtime at run time to facilitate a **managed** to **native** transition.

**Managed** &ndash; Code running under the control of a virtual machine where memory is managed automatically by a Garbage Collector (for example, .NET runtime). When referring to memory or data its lifetime is managed automatically.

**Marshal** &ndash; The process of converting data when transitioning between **managed** and **native** code.

**Native** &ndash; Code running where memory is managed manually by the developer (for example, C or C++). When referring to memory or data its lifetime is managed manually.

[**Pinning**][doc_pinning] &ndash; Mechanism used to indicate to the Garbage Collector not to move the **managed** data.

**Reverse IL Stub** &ndash; A function generated by the .NET runtime at run time to facilitate a **native**  to **managed** transition.

**Unmanaged** &ndash; See **native**. The ['unmanaged'][doc_unmanaged_types] term is also used with the C# language and has special meaning for .NET interoperability with C#.

### Transitioning between Managed and Native <a name="transition"></a>

Declaring the previous C function to be callable in C# is accomplished via [`DllImportAttribute`][api_dllimport] &ndash; also called a [P/Invoke][doc_pinvoke]. Assuming the C function is contained within a C library named `NativeLib.dll`, the following C# would declare the native function. Other mechanisms for defining callable native functions in IL are discussed in subsequent sections.

```csharp
[DllImport("NativeLib.dll")]
static extern int sum_ints(int length, int[] integers);
```

This P/Invoke declaration enables the C function to be called in C# but this call is not as simple as it may appear. Given this P/Invoke declaration an implicit function will also need to be constructed.

The implicit function is what is called an IL Stub. This IL Stub is a stream of IL instructions computed at run time by the interop system to marshal the function arguments from managed to native. There are a number of considerations that must be accounted for by the IL Stub but for the purposes of this example the IL Stub's responsibility is to ensure the two arguments are safely passed to the native function and the native function's return value is returned to the C# caller. An annotated and slightly modified example of an IL Stub is below. It is similar to what would be generated by the .NET runtime.

```
int32 ILStub_sum_ints(int32,int32[])
.locals (int64,native int,object pinned)
          ldarg.0
          conv.i8
          stloc.0       // Store input length as 64-bit number.
          ldc.i4.0
          conv.i
          stloc.1       // Initialize pointer local to null.
          ldarg.1       // Load and check if array is null.
          brfalse     NO_ARRAY
          ldarg.1
          stloc.2       // Pin the array so GC won't move it.
          ldloc.2
          conv.i
          ldc.i4.s    0x10
          add
          stloc.1       // Store pointer to managed array data.
NO_ARRAY :ldloc.0       // Load input length.
          ldloc.1       // Load pointer to managed array data.
          call        native int GetStubContext()
          ldc.i4.s    0x20
          add
          ldind.i
          ldind.i       // Load pointer to native function.
          calli       unmanaged stdcall int32(int64,native int)
          ret           // Return value on stack.
```

The precise details of the IL Stub aren't necessary to understand but the general flow is described to help illustrate its purpose. With the above IL Stub, a C# application can now call the `sum_ints()` function written in C.

```csharp
int[] arr = new[] { 1, 2, 3 };
int len = arr.Length;

int sum = sum_ints(len, arr);

// During the call to the P/Invoke the call stack
// will be the following:
//  - ILStub_sum_ints(len, arr) // C#
//      Locals:
//          int64  l0  = len
//          int*   l1  = pointer into arr's data
//          object l2  = pinned arr
//      - sum_ints(l0, l1)      // C
```

During a transition from native to managed a Reverse IL Stub is generated. This stub performs similar duties to the one defined above but in the opposite direction &ndash; marshals data from native to managed.

This represents a conceptual introduction into how the .NET runtime handles interop.

## Concepts <a name="concepts"></a>

There are some fundamental concepts in .NET interop that provide a core understanding to how the system works and what is and isn't possible. Some of these concepts are only exposed in IL or some times limited to a single .NET language (for example, C# with [`unmanaged` function pointers](https://docs.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers)). The concepts below are continually used when designing a solution involving interop. None of them are exhaustively explained here, rather the below represents the salient points on the concepts as they relate to interop.

### Garbage Collection <a name="gc"></a>

The entire .NET system is based around Garbage Collection. For interop, Garbage collection will be mentioned as the answer to the "why" in many cases. Be aware that Garbage collection is a vast topic and only a narrow aspect of it will be discussed here. For a deeper understanding of the .NET Garbage Collector (GC) the [Book of the Runtime][doc_botr] (BOTR) should be used or the excellent [mem-doc][repo_mem_doc] maintained by the GC architect.

What should be known about the GC is that memory allocated by the GC (that is, managed memory) that is directly exposed to native code requires coordination with the GC. This coordination means providing a way to let the GC know that native code may be using managed memory when attempting to collect "garbage" &ndash; one of its responsibilities. Another GC responsibility is to make efficient use of the memory it owns. This may entail compacting managed memory as holes are created between allocations during collection. These two GC responsibilities create two concerns when using managed memory in native code:

1) The GC collects the memory since there is no other managed code using it.
1) The GC moves the memory to a different address.

One coordination mechanism was demonstrated in the [Introduction](#intro). Recall that the `int[]` passed to the P/Invoke was "pinned" prior to passing the `int*` to native code. Pinning let the GC know the `int[]` shouldn't be moved from its current location in memory. It was still referenced in the method calling the native function so issue (1) above wasn't a concern. The example in the Introduction was in IL, but pinning can be accomplished in C# using the [`fixed`](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/fixed-statement) statement. 

Another mechanism is to use a [`GCHandle`][api_gchandle]. This provides a level of indirection to managed memory which means the `GCHandle` can be passed around instead of the managed memory itself. The `GCHandle` helps with (1) since it extends the managed memory's lifetime. The `GCHandle` API is powerful and has additional options that also enable it to handle (2) &ndash; see [`GCHandleType.Pinned`](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.gchandletype) &ndash; and even permit some insight into if the managed memory was collected &ndash; see [`GCHandleType.WeakTrackResurrection`](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.gchandletype).

These two mechanisms are incredibly powerful and provide the needed coordination with the GC to make .NET interoperability with native code possible.

### Referencing Memory <a name="referencingmemory"></a>

Indirectly referencing memory is an important feature of any programming model. Levels of indirection present challenges for interop in languages like IL and C# that permit levels of indirection to both managed and native memory at the same time. Below is an example of some C# and equivalent IL, in comments, that illustrate levels of indirection.

```csharp
void Method(
    in Class ic,    /* [in] class Class& ic        */
    ref Class rc,   /* class Class& rc             */
    out Class oc,   /* [out] class Class& oc       */
    in Struct iv,   /* [in] valuetype Struct& iv   */
    ref Struct rv,  /* valuetype Struct& rv        */
    out Struct ov,  /* [out] valuetype Struct& ov  */
    Struct* pv,     /* valuetype Struct* pv        */
    in int ii,      /* [in] int32& ii              */
    ref int ri,     /* int32& ri                   */
    out int oi,     /* [out] int32& oi             */
    int* pi)        /* int32* pi                   */
{ ... }
```

The above may appear to be a significant number of options but in reality, at the IL level, there are only two &ndash; the `&` and the `*`. The `[in]` and `[out]` represent metadata that carries semantic importance but doesn't impact the level of indirection. The `&` represents a reference to managed memory. This should not be confused with the C++ use of `&` &ndash; although they do share similar semantics. Note that the C# keywords `in`, `ref`, and `out` all reduce to managed references. The other, `*`, represents a native level of indirection or pointer to memory. This one is identical to the `*` found in C or C++. Note here that an example of a native pointer to a `Struct` and `int` are illustrated, but not to `Class`. When and how these indicators are applied to memory tells the interop system a lot about how the referenced memory should be treated during a transition between managed and native code.

The use of native indirection (`*`, pointer) is more restrictive in practice and often limited to interop scenarios. Since .NET language compilers tend to help out and inform when it is and isn't possible to get a pointer to memory it is often acquired correctly; however once it is acquired, misuse can cause catastrophic issues. The pointer has all the same implications and assumptions inherent in a native environment.

- The memory pointed at will not move.
- The memory will exist until some explicit 'release'/'free'/'delete' action is performed.

In order to get a pointer to managed memory on the .NET platform some coordination with the GC must be performed &ndash; see [Garbage Collection](#gc) for options. What types of memory a pointer can point at are also limited. For the C# example above notice the `Class` type does not have a pointer example. This is because it is not an [unmanaged type][doc_unmanaged_types]. Only unmanaged types may be what is called the "referent" of a pointer.

Getting a pointer to native memory is as simple as having it be returned/passed from a native function or calling a managed API that is documented to return native memory (for example, [`Marshal.AllocCoTaskMem()`](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.marshal.alloccotaskmem)).

Referencing managed memory with `&` has much broader implications because it indicates the memory being referenced is also tracked by the GC. This level of indirection is not limited in C# to unmanaged types because the reference is only usable when in a managed environment. It is possible to convert a `&` to a `*`, but the referent must be an unmanaged type. For example the `ref Struct rv` argument above could be converted to a pointer in C# as follows:

```csharp
fixed (Struct* prv = &rv)
{
    ...
}
```

Observe though that in order to convert to a pointer coordination with the GC was performed. The `fixed` statement indicated that regardless of where this `Struct` is actually located, it mustn't be moved from that location.

### Blittable vs Unmanaged types <a name="blittablevsunmanaged"></a>

These two concepts are important in interop &ndash; especially when involving the C# language. The two are closely related but are not equivalent and can cause confusion when thinking about interop. Both are defined in the [Terminology](#term) section but examples and additional clarity are warranted.

[Blittable types][doc_blittable] are those types that have the same layout in memory in both managed and native environments. Since blittable isn't defined in the [ECMA-335][spec_ecma335] specification, runtime implementations are free to optimize cases where types aren't technically blittable but can be treated as such under certain circumstances.

[Unmanaged types][doc_unmanaged_types] are defined in the C# specification and are not related to blittability at all.

Consider the following .NET types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`. Every one of these types has a representation that is the same in both a managed and native environment - so they are blittable. All of them are also defined as C# unmanaged types.

There are however unmanaged types that are not blittable. The .NET types `bool`, `char`, and enumerations are unmanaged types, but are not considered blittable. The reason for this is partially historical and partially based on ECMA-335. The `bool` is specified as a single byte in .NET, but historically is marshalled as an `int` to align with the Windows' `BOOL` type. The `char` is specified to be a two-byte 16-bit value, but the native mapping for a character in C/C++ could be either [`char`](https://en.cppreference.com/w/cpp/keyword/char) or [`wchar_t`](https://en.cppreference.com/w/cpp/keyword/wchar_t), which are 1 byte and 2 bytes respectively on the Windows platform. The `wchar_t` is particularly difficult given it is 4-bytes on some non-Windows platforms. Finally, the ECMA-335 specification in II.14.3 defines the underlying type of an enumeration may be any numeric type or a `bool` or `char`. This means that an enumeration can't always be considered blittable.

The opposite case is also possible &ndash; blittable but not unmanaged. Single dimension arrays of blittable primitive types are considered blittable by the interop system but are not unmanaged types. Considering single dimension arrays of blittable primitive types as blittable is an example of a runtime implementation optimization.

## C++/CLI <a name="cppcli"></a>

Support for writing C++ to run in a .NET runtime is accomplished using a language called C++/CLI as specified in [ECMA-372][spec_ecma372]. At present, the [C++/CLI language][doc_cppcli] is only supported by the VC++ compiler and limited exclusively to the Windows platform. One of the goals of C++/CLI was to make interoperability between native and managed code seamless and sort of magic &ndash; that is why it is commonly referred to as IJW or "It-Just-Works". C++/CLI's goal of making interop simpler is laudable, but given its design, it comes with non-trivial costs in terms of implementation and requires a deeper understanding of interop as opposed performing it from within a language like C#.

Comprehensive official documentation for C++/CLI can be found [here][doc_cppcli].

There are 4 modes of operation for a C++/CLI compiled assembly. The documentation for these modes is relatively vague so additional details are added here. The VC++ compiler will compile a C++/CLI assembly when passed the [`/clr`](https://docs.microsoft.com/cpp/build/reference/clr-common-language-runtime-compilation) flag.

|Mode|Operation|
|-|-|
|_none_| The default mode. The resulting assembly may contain both native and managed code. The assembly is linked against `mscoree.lib` and only runs on .NET Framework. |
|`pure`| **Deprecated**. The resulting assembly contains only managed code. All native data types are converted to pure managed types. The assembly is linked against `mscoree.lib` and only runs on .NET Framework. |
|`safe`| **Deprecated**. The resulting assembly may contain both native and managed code, but no native memory dereferences are permitted in the native code. The intent of this build is to produce verifiable code (that is, no `unsafe` code). The assembly is linked against `mscoree.lib` and only runs on .NET Framework.|
|`NetCore`| This mode is identical to the default but links against `ijwhost.lib` and only runs on .NET Core 3.1 or .NET 5+. |

If either of the two deprecated modes are desired, it is strongly recommended to write in or port code to a pure .NET language (for example, C#).

### C++ language extensions <a name="cppcli_cpplangext"></a>

The C++/CLI language is an  extension of C++ that attempts to express .NET interop [Concepts](#concepts) in C++ &ndash; the most important being memory ownership and levels of indirection.

**`&`** &ndash; A native reference to native memory. This is the [C++ construct](https://en.cppreference.com/w/cpp/language/reference) and has the same semantics. This should not be confused with the `&` defined above when talking about managed references in IL &ndash; a completely different language.

**`*`** &ndash; A native pointer to native memory. This is the [C++ construct](https://en.cppreference.com/w/cpp/language/pointer) and has the same semantics.

**`%`** &ndash; A managed reference, also called a ["tracking reference"](https://docs.microsoft.com/cpp/dotnet/how-to-use-tracking-references-in-cpp-cli), to managed memory. This is a new construct and provides symmetry with the native `&` construct but for managed.

**`^`** &ndash; A managed pointer to managed memory. This is a new construct and provides symmetry with the native `*` construct but for managed. The managed pointer is also used for all managed type instances that derive from [`System.Object`][api_object] (that is, [reference types][wiki_valuereftypes]). For example, `Object^ o = gcnew Object;`.

Examples of these constructs in C++/CLI can be found in the [official documentation][doc_cppcli].

Regardless of how these constructs are used in practice, their function should be clear &ndash; coordination with the [GC](#gc) to help share memory between native and managed environments.

### Activation of the .NET runtime <a name="cppcli_activation"></a>

Introducing .NET into an existing native application is a common scenario where C++/CLI is employed. Imagine a large native application that would like to leverage an existing .NET library. Since the applicaion is native, this would imply that a .NET runtime instance is not already running in the process and the main entry point is native (for example, [`int main()`](https://en.cppreference.com/w/cpp/language/main_function)). When a C++/CLI assembly is loaded into the process, the .NET runtime must be initialized and prepared to operate in this process prior to any managed code running.

There are are two types of .NET runtime activation for C++/CLI &ndash; .NET Framework and .NET Core 3.1/.NET 5+. These two types are mechanically similar once the .NET runtime is loaded and initialized but prior to that the details are very different.

**.NET Framework** &ndash; The C++/CLI assembly is implicitly linked against `mscoree.lib`. The linking indicates the assembly has a dependency on the native `mscoree.dll` binary and must be loaded prior to the assembly being executed. The `mscoree.dll` binary is located globally (for example, `%SystemRoot%\System32\mscoree.dll`) on the Windows platform and facilitates loading the .NET runtime. The version of the runtime (that is, `2.0`, `3.5`, or `4.5`+) that is loaded is influenced by additional flags passed during the compilation, an `app.config`, or global settings.

**.NET Core 3.1** and **.NET 5+** &ndash; The C++/CLI assembly is implicitly linked against `ijwhost.lib` and thus requires `ijwhost.dll` during load. The `ijwhost.dll` binary is not necessarily globally installed and available. This makes it a dependency that must be provided in another manner (for example, update `PATH` environment variable). Once the `ijwhost.dll` is loaded, it reads an associated `<CPPCLI_ASSEMBLY_NAME>.runtimeconfig.json` file to determine which .NET runtime is needed by the assembly. If an existing .NET runtime is already loaded, that runtime version is validated it supports the needs of the requested version and the `Microsoft.WindowsDesktop.App` framework is loaded. Version reconciliation is non-trivial and has many options that are described in detail [here](https://github.com/dotnet/runtime/blob/main/docs/design/features/framework-version-resolution.md). The design document for this process can be found in the [`dotnet/runtime`][design_ijw_activation] repository.

Once the specific native dependency (that is, `mscoree.dll`/`ijwhost.dll`) is loaded, all managed exports exposed to native code are "thunked". This thunk provides a level of indirection between the actual managed function and the calling native code in order to load the .NET runtime on demand. The first time a managed function is called by native code, the thunk is executed and a .NET runtime loaded or the existing one confirmed to be compatible and adopted. All native exports are then populated with the appropriate managed function. Only one managed call must pay this initialization price since all thunks for an assembly will be updated when it is loaded into a .NET runtime. After a .NET runtime has loaded the assembly and the managed function thunks have been updated, the interop experience follows all the rules and principles described in the [Concepts](#concepts) section.


<!--
## IL Stubs and Reverse IL Stubs <a name="ilstubs"></a>

## COM and `IUnknown` <a name="comiunknown"></a>

### WinRT <a name="winrt"></a>

## Migration from .NET Framework <a name="migration"></a>

## Gotchas <a name="gotchas"></a>
-->

## Tooling <a name="tooling"></a>

Multiple tools exist for building interop solutions in .NET interop. Below is a list of tools that may be useful for .NET applications with interop requirements.

[SharpGenTools](https://github.com/SharpGenTools/SharpGenTools) &ndash; Compile time generation of interop marshalling code for P/Invokes and the `IUnknown` ABI.

[C#/WinRT][repo_cswinrt] &ndash; Compile time generation of WinRT type projections into .NET.

[DNNE][repo_dnne] &ndash; Export C functions from a managed assembly.

[SharpLab](https://sharplab.io/) &ndash; Website used to view compiled C# as IL.

## Additional Resources

[Investigating GC managed memory][repo_mem_doc].

[Book of the Runtime][doc_botr].

<!-- Reusable links -->

[api_dllimport]:https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.dllimportattribute
[api_gchandle]:https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.gchandle
[api_iunknown]:https://docs.microsoft.com/windows/win32/api/unknwn/nn-unknwn-iunknown
[api_object]:https://docs.microsoft.com/dotnet/api/system.object

[design_ijw_activation]:https://github.com/dotnet/runtime/blob/main/docs/design/features/IJW-activation.md

[doc_blittable]:https://docs.microsoft.com/dotnet/framework/interop/blittable-and-non-blittable-types
[doc_botr]:https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/README.md
[doc_com]:https://docs.microsoft.com/windows/win32/com/the-component-object-model
[doc_cppcli]:https://docs.microsoft.com/cpp/dotnet/dotnet-programming-with-cpp-cli-visual-cpp
[doc_pinning]:https://docs.microsoft.com/dotnet/framework/interop/copying-and-pinning
[doc_pinvoke]:https://docs.microsoft.com/dotnet/standard/native-interop/pinvoke
[doc_unmanaged_types]:https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/unmanaged-types

[spec_ecma335]:https://www.ecma-international.org/publications-and-standards/standards/ecma-335/
[spec_ecma372]:https://www.ecma-international.org/publications-and-standards/standards/ecma-372/

[repo_cswinrt]:https://github.com/microsoft/CsWinRT
[repo_dnne]:https://github.com/AaronRobinsonMSFT/DNNE
[repo_mem_doc]:https://github.com/Maoni0/mem-doc

[wiki_x86callconv]:https://wikipedia.org/wiki/X86_calling_conventions
[wiki_valuereftypes]:https://wikipedia.org/wiki/Value_type_and_reference_type