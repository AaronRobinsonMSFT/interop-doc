# .NET Interop Document

**Context for this document is always relative to the [current release of the .NET platform.](https://dotnet.microsoft.com/download)**

### Contents

- [Introduction](#intro) &ndash; Introduction to how interoperability works in .NET.
    - [Terminology](#terms).
    - [Transitioning between Managed and Native](#transition).
- [Concepts](#concepts) &ndash; Fundamental ideas in .NET interoperability.
    - [Garbage Collection](#gc) &ndash; Pinning and `GCHandle`s.
    - [Referencing Memory](#referencingmemory).
    - [Blittable vs Unmanaged types](#blittablevsunmanaged).

<!-- 
- [IL Stubs and Reverse IL Stubs](#ilstubs) &ndash; How stubs are generated and runtime optimizations.
    - [Diagnostics] &ndash; How to see the generated IL Stub.
- [COM and `IUnknown`](#comiunknown) &ndash; COM interoperability in .NET.
    - [WinRT](#winrt)
- [C++/CLI](#cppcli)
- [Migration from .NET Framework](#migration) &ndash; Options when migrating from .NET Framework.
- [Gotchas](#gotchas) &ndash; Common interop issues.
-->
- [Tooling](#tooling) &ndash; Tools that can help building interop scenarios.

## Introduction <a name="intro"></a>

The .NET interop system is an intrinsic part of the .NET platform and its impact can be observed down to the binary level &ndash; defined in [ECMA-335][spec_ecma335]. The representation of C language function exports with the common [x86 calling conventions][wiki_x86callconv] at the time of writing are literally able to be encoded at the lowest readable level. The lowest level in this case is termed "Intermediate Language" or "IL". The point of interop in .NET is to express in IL how software _not_ defined in IL and _not_ the .NET platform itself should work with logic and data owned and managed by a .NET runtime implementation.

An example is warranted. Imagine wanting to call the following C function from a .NET language (for example, C#).

```C
// Return the sum of the supplied array of integers.
int32_t sum_ints(int32_t length, int32_t* integers)
{
    int32_t acc = 0;
    for (int32_t i = 0; i < length; ++i)
        acc += integers[i];
    return acc;
}
```

In order to call this function it must first be declared in a manner that permits being called in C#. The .NET runtime will also need to know the name of the C library the function is defined in. The arguments to this function must also be considered. Since the first argument is a primitive type in both C and .NET (that is, a 4 byte integer) how it is passed to this function is relatively straight forward. The second argument is more complicated because it is an array. In order to pass a C# array naturally to this function, the .NET runtime must convert an `int[]` to a C `int32_t*`. This is the nature of .NET interoperability &ndash; working with a system that is not .NET.

### Terminology <a name="terms"></a>

Understanding the .NET interop domain is difficult without defining common jargon. Below is a list of terms used throughout this document. Terms are **bolded** in definitions when also defined in this section.

[**Blittable**][doc_blittable] &ndash; Data that has the same representation within and outside the .NET platform. Blittable data doesn't need to be **marshalled**. This term is a concept and not explicitly defined by the ECMA-335 specification or any .NET language.

**IL Stub** &ndash; A function generated by the .NET runtime at run time to facilitate a **managed** to **native** transition.

**Managed** &ndash; Code running under the control of a virtual machine where memory is managed automatically by a Garbage Collector (for example, .NET runtime). When referring to memory or data its lifetime is managed automatically.

**Marshal** &ndash; The process of converting data when transitioning between **managed** and **native** code.

**Native** &ndash; Code running where memory is managed manually by the developer (for example, C or C++). When referring to memory or data its lifetime is managed manually.

[**Pinning**][doc_pinning] &ndash; Mechanism used to indicate to the Garbage Collector not to move the **managed** data.

**Reverse IL Stub** &ndash; A function generated by the .NET runtime at run time to facilitate a **native**  to **managed** transition.

**Unmanaged** &ndash; See **native**. The ['unmanaged'][doc_unmanaged_types] term is also used with the C# language and has special meaning for .NET interoperability with C#.

### Transitioning between Managed and Native <a name="transition"></a>

Declaring the previous C function to be callable in C# is accomplished via [`DllImportAttribute`][api_dllimport] &ndash; also called a [P/Invoke][doc_pinvoke]. Assuming the C function is contained within a C library named `NativeLib.dll`, the following C# would declare the native function. Other mechanisms for defining callable native functions in IL are discussed in subsequent sections.

```csharp
[DllImport("NativeLib.dll")]
static extern int sum_ints(int length, int[] integers);
```

This P/Invoke declaration enables the C function to be called in C# but this call is not as simple as it may appear. Given this P/Invoke declaration an implicit function will also need to be constructed.

The implicit function is what is called an IL Stub. This IL Stub is a stream of IL instructions computed at run time by the interop system to marshal the function arguments from managed to native. There are a number of considerations that must be accounted for by the IL Stub but for the purposes of this example the IL Stub's responsibility is to ensure the two arguments are safely passed to the native function and the native function's return value is returned to the C# caller. An annotated and slightly modified example of an IL Stub is below. It is similar to what would be generated by the .NET runtime.

```
int32 ILStub_sum_ints(int32,int32[])
.locals (int64,native int,object pinned)
          ldarg.0
          conv.i8
          stloc.0       // Store input length as 64-bit number.
          ldc.i4.0
          conv.i
          stloc.1       // Initialize pointer local to null.
          ldarg.1       // Load and check if array is null.
          brfalse     NO_ARRAY
          ldarg.1
          stloc.2       // Pin the array so GC won't move it.
          ldloc.2
          conv.i
          ldc.i4.s    0x10
          add
          stloc.1       // Store pointer to managed array data.
NO_ARRAY :ldloc.0       // Load input length.
          ldloc.1       // Load pointer to managed array data.
          call        native int GetStubContext()
          ldc.i4.s    0x20
          add
          ldind.i
          ldind.i       // Load pointer to native function.
          calli       unmanaged stdcall int32(int64,native int)
          ret           // Return value on stack.
```

The precise details of the IL Stub aren't necessary to understand but the general flow is described to help illustrate its purpose. With the above IL Stub, a C# application can now call the `sum_ints()` function written in C.

```csharp
int[] arr = new[] { 1, 2, 3 };
int len = arr.Length;

int sum = sum_ints(len, arr);

// During the call to the P/Invoke the call stack
// will be the following:
//  - ILStub_sum_ints(len, arr) // C#
//      Locals:
//          int64  l0  = len
//          int*   l1  = pointer into arr's data
//          object l2  = pinned arr
//      - sum_ints(l0, l1)      // C
```

During a transition from native to managed a Reverse IL Stub is generated. This stub performs similar duties to the one defined above but in the opposite direction &ndash; marshals data from native to managed.

This represents a conceptual introduction into how the .NET runtime handles interop.

## Concepts <a name="concepts"></a>

There are some fundamental concepts in .NET interop that provide a core understanding to how the system works and what is and isn't possible. Some of these concepts are only exposed in IL or some times limited to a single .NET language (for example, C# with [`unmanaged` function pointers](https://docs.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers)). The concepts below are continually used when designing a solution involving interop. None of them are exhaustively explained here, rather the below represents the salient points on the concepts as they relate to interop.

### Garbage Collection <a name="gc"></a>

The entire .NET system is based around Garbage Collection. For interop, Garbage collection will be mentioned as the answer to the "why" in many cases. Be aware that Garbage collection is a vast topic and only a narrow aspect of it will be discussed here. For a deeper understanding of the .NET Garbage Collector (GC) the [Book of the Runtime][doc_botr] (BOTR) should be used or the excellent [mem-doc][repo_mem_doc] maintained by the GC architect.

What should be known about the GC is that memory allocated by the GC (that is, managed memory) that is directly exposed to native code requires coordination with the GC. This coordination means providing a way to let the GC know that native code may be using managed memory when attempting to collect "garbage" &ndash; one of its responsibilities. Another GC responsibility is to make efficient use of the memory it owns. This may entail compacting managed memory as holes are created between allocations during collection. These two GC responsibilities create two concerns when using managed memory in native code:

1) The GC collects the memory since there is no other managed code using it.
1) The GC moves the memory to a different address.

One coordination mechanism was demonstrated in the [Introduction](#intro). Recall that the `int[]` passed to the P/Invoke was "pinned" prior to passing the `int*` to native code. Pinning let the GC know the `int[]` shouldn't be moved from its current location in memory. It was still referenced in the method calling the native function so issue (1) above wasn't a concern. The example in the Introduction was in IL, but pinning can be accomplished in C# using the [`fixed`](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/fixed-statement) statement. 

Another mechanism is to use a [`GCHandle`][api_gchandle]. This provides a level of indirection to managed memory which means the `GCHandle` can be passed around instead of the managed memory itself. The `GCHandle` helps with (1) since it extends the managed memory's lifetime. The `GCHandle` API is powerful and has additional options that also enable it to handle (2) &ndash; see [`GCHandleType.Pinned`](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.gchandletype) &ndash; and even permit some insight into if the managed memory was collected &ndash; see [`GCHandleType.WeakTrackResurrection`](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.gchandletype).

These two mechanisms are incredibly powerful and provide the needed coordination with the GC to make .NET interoperability with native code possible.

### Referencing Memory <a name="referencingmemory"></a>

Indirectly referencing memory is an important feature of any programming model. Levels of indirection present challenges for interop in languages like IL and C# that permit levels of indirection to both managed and native memory at the same time. Below is an example of some C# and equivalent IL, in comments, that illustrate levels of indirection.

```csharp
void Method(
    in Class ic,    /* [in] class Class& ic        */
    ref Class rc,   /* class Class& rc             */
    out Class oc,   /* [out] class Class& oc       */
    in Struct iv,   /* [in] valuetype Struct& iv   */
    ref Struct rv,  /* valuetype Struct& rv        */
    out Struct ov,  /* [out] valuetype Struct& ov  */
    Struct* pv,     /* valuetype Struct* pv        */
    in int ii,      /* [in] int32& ii              */
    ref int ri,     /* int32& ri                   */
    out int oi,     /* [out] int32& oi             */
    int* pi)        /* int32* pi                   */
{ ... }
```

The above may appear to be a significant number of options but in reality, at the IL level, there are only two &ndash; the `&` and the `*`. The `[in]` and `[out]` represent metadata that carries semantic importance but doesn't impact the level of indirection. The `&` represents a reference to managed memory. This should not be confused with the C++ use of `&` &ndash; although they do share similar semantics. Note that the C# keywords `in`, `ref`, and `out` all reduce to managed references. The other, `*`, represents a native level of indirection or pointer to memory. This one is identical to the `*` found in C or C++. Note here that an example of a native pointer to a `Struct` and `int` are illustrated, but not to `Class`. When and how these indicators are applied to memory tells the interop system a lot about how the referenced memory should be treated during a transition between managed and native code.

The use of native indirection (`*`, pointer) is more restrictive in practice and often limited to interop scenarios. Since .NET language compilers tend to help out and inform when it is and isn't possible to get a pointer to memory it is often acquired correctly; however once it is acquired, misuse can cause catastrophic issues. The pointer has all the same implications and assumptions inherent in a native environment.

- The memory pointed at will not move.
- The memory will exist until some explicit 'release'/'free'/'delete' action is performed.

In order to get a pointer to managed memory on the .NET platform some coordination with the GC must be performed &ndash; see [Garbage Collection](#gc) for options. What types of memory a pointer can point at are also limited. For the C# example above notice the `Class` type does not have a pointer example. This is because it is not an [unmanaged type][doc_unmanaged_types]. Only unmanaged types may be what is called the "referent" of a pointer.

Getting a pointer to native memory is as simple as having it be returned/passed from a native function or calling a managed API that is documented to return native memory (for example, [`Marshal.AllocCoTaskMem()`](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.marshal.alloccotaskmem)).

Referencing managed memory with `&` has much broader implications because it indicates the memory being referenced is also tracked by the GC. This level of indirection is not limited in C# to unmanaged types because the reference is only usable when in a managed environment. It is possible to convert a `&` to a `*`, but the referent must be an unmanaged type. For example the `ref Struct rv` argument above could be converted to a pointer in C# as follows:

```csharp
fixed (Struct* prv = &rv)
{
    ...
}
```

Observe though that in order to convert to a pointer coordination with the GC was performed. The `fixed` statement indicated that regardless of where this `Struct` is actually located, it mustn't be moved from that location.

### Blittable vs Unmanaged types <a name="blittablevsunmanaged"></a>

These two concepts are important in interop &ndash; especially when involving the C# language. The two are closely related but are not equivalent and can cause confusion when thinking about interop. Both are defined in the [Terminology](#term) section but examples and additional clarity are warranted.

[Blittable types][doc_blittable] are those types that have the same layout in memory in both managed and native environments.

[Unmanaged types][doc_unmanaged_types] are defined in the C# specification and are not related to blittability at all.

Consider the following .NET types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`. Every one of these types has a well defined size and representation in both a managed and native environment - so they are blittable. All of them are also defined as C# unmanaged types.

There are however unmanaged types that are not blittable. The .NET types `bool`, `char`, and enumerations are not considered blittable but are unmanaged types. The reason for this is partially historical and partially based on [ECMA-335][spec_ecma335]. The `bool` is specified as a single byte in .NET but historically is marshalled as an `int` to align with the Windows' `BOOL` type. The `char` is specified to be a two byte 16-bit value, but the native mapping for a character in C/C++ could be either [`char`](https://en.cppreference.com/w/cpp/keyword/char) or [`wchar_t`](https://en.cppreference.com/w/cpp/keyword/wchar_t), which are 1 byte and 2 bytes respectively on the Windows platform. The `wchar_t` is particularly difficult given it is 4-bytes on some non-Windows platforms. Finally, the ECMA-335 specification in II.14.3 defines the underlying type of an enumeration can be any numeric type or a `bool` or `char`. This means that an enumeration can't always be considered blittable.

The opposite case is also true, blittable but not unmanaged. Single dimension arrays of blittables types are considered blittable by the interop system but are not unmanaged types.

<!--
## IL Stubs and Reverse IL Stubs <a name="ilstubs"></a>

## COM and `IUnknown` <a name="comiunknown"></a>

### WinRT <a name="winrt"></a>

## C++/CLI <a name="cppcli"></a>

## Migration from .NET Framework <a name="migration"></a>

## Gotchas <a name="gotchas"></a>
-->

## Tooling <a name="tooling"></a>

Multiple tools exist for building interop solutions in .NET interop. Below is a list of tools that may be useful for .NET applications with interop requirements.

[SharpGenTools](https://github.com/SharpGenTools/SharpGenTools) &ndash; Compile time generation of interop marshalling code for P/Invokes and the `IUnknown` ABI.

[C#/WinRT][repo_cswinrt] &ndash; Compile time generation of WinRT type projections into .NET.

[DNNE][repo_dnne] &ndash; Export C functions from a managed assembly.

[SharpLab](https://sharplab.io/) &ndash; Website used to view compiled C# as IL.

## Additional Resources

[Investigating GC managed memory][repo_mem_doc].

[Book of the Runtime][doc_botr].

<!-- Reusable links -->

[api_dllimport]:https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.dllimportattribute
[api_gchandle]:https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.gchandle
[api_iunknown]:https://docs.microsoft.com/windows/win32/api/unknwn/nn-unknwn-iunknown

[doc_blittable]:https://docs.microsoft.com/dotnet/framework/interop/blittable-and-non-blittable-types
[doc_botr]:https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/README.md
[doc_com]:https://docs.microsoft.com/windows/win32/com/the-component-object-model
[doc_pinning]:https://docs.microsoft.com/dotnet/framework/interop/copying-and-pinning
[doc_pinvoke]:https://docs.microsoft.com/dotnet/standard/native-interop/pinvoke
[doc_unmanaged_types]:https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/unmanaged-types

[spec_ecma335]:https://www.ecma-international.org/publications-and-standards/standards/ecma-335/

[repo_cswinrt]:https://github.com/microsoft/CsWinRT
[repo_dnne]:https://github.com/AaronRobinsonMSFT/DNNE
[repo_mem_doc]:https://github.com/Maoni0/mem-doc

[wiki_x86callconv]:https://en.wikipedia.org/wiki/X86_calling_conventions